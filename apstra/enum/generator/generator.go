// Copyright (c) Juniper Networks, Inc., 2024-2024.
// All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// Code generation based on GopherCon UK 2019 talk by Paul Jolly:
// Write Less (Code), Generate More
// https://www.youtube.com/watch?v=xcpboZZy-64

package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"path"
	"text/template"
	"time"

	"golang.org/x/tools/go/packages"
)

const (
	inFile          = "enums.go"
	outFile         = "generated_" + inFile
	outFileTemplate = `` +
		`// Copyright (c) Juniper Networks, Inc., 2024-{{.Year}}.
// All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// contents of this file are auto-generated by ./generator/generator.go - DO NOT EDIT

package enum

import oenum "github.com/orsinium-labs/enum"
{{ range $key, $value := .TypeToVals }}
var _ enum = (*{{ $key }})(nil)

func (o {{ $key }}) String() string {
	return o.Value
}

func (o *{{ $key }}) FromString(s string) error {
	if {{ $key }}s.Parse(s) == nil {
		return newEnumParseError(o, s)
	}
	o.Value = s
	return nil
}
{{ end }}
var ({{ range  $key, $value := .TypeToVals }}
	_ enum = new({{ $key }})
	{{ $key }}s = oenum.New({{ range $v := $value }}
		{{ $v }},{{ end }}
	)
{{ end }})
`
)

var TypeToVals map[string][]string

func main() {
	TypeToVals = make(map[string][]string)

	cfg := packages.Config{Mode: packages.NeedTypes | packages.NeedSyntax}

	pkgs, err := packages.Load(&cfg)
	if err != nil {
		panic(fmt.Errorf("while loading packages - %w", err))
	}

	if len(pkgs) != 1 {
		panic(fmt.Errorf("expected 1 package, got %d packages", len(pkgs)))
	}
	pkg := pkgs[0]

	for _, file := range pkg.Syntax {
		absPath := pkg.Fset.Position(file.Package).Filename
		if path.Base(absPath) != inFile {
			continue
		}

		for _, decl := range file.Decls {
			gd, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			if gd.Tok != token.VAR {
				continue
			}

			err = handleVar(gd)
			if err != nil {
				panic(err)
			}
		}
	}

	err = render()
	if err != nil {
		panic(fmt.Errorf("while rendering template - %w", err))
	}
}

func render() error {
	var data struct {
		Year       string
		TypeToVals map[string][]string
	}

	data.Year = time.Now().Format("2006")
	data.TypeToVals = TypeToVals

	f, err := os.Create(outFile)
	if err != nil {
		return fmt.Errorf("while creating file for generated code - %w", err)
	}

	tmpl, err := template.New("").Parse(outFileTemplate)
	if err != nil {
		return fmt.Errorf("while parsing template - %w", err)
	}

	err = tmpl.Execute(f, data)
	if err != nil {
		return fmt.Errorf("while executing template - %w", err)
	}

	err = f.Close()
	if err != nil {
		return fmt.Errorf("while closing file %q - %w", outFile, err)
	}

	return nil
}

func handleVar(gd *ast.GenDecl) error {
	for _, spec := range gd.Specs {
		spec, ok := spec.(*ast.ValueSpec)
		if !ok {
			return fmt.Errorf("spec should have been a ValueSpec, got %v", spec)
		}

		if len(spec.Names) != 1 {
			return fmt.Errorf("expected 1 spec name, got %d spec naems", len(spec.Names))
		}

		if len(spec.Values) != 1 {
			return fmt.Errorf("expected 1 spec value, got %d spec values", len(spec.Values))
		}

		name := spec.Names[0]
		value, ok := spec.Values[0].(*ast.CompositeLit)
		if !ok {
			continue
		}

		valueType, ok := value.Type.(*ast.Ident)
		if !ok {
			continue
		}

		tName := valueType.Name

		TypeToVals[tName] = append(TypeToVals[tName], name.Name)
	}

	return nil
}
