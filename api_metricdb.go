package goapstra

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"time"
)

const (
	apiUrlMetricdbMetric = "/api/metricdb/metric"
	apiUrlMetricdbQuery  = "/api/metricdb/query"

	MetricdbAppHealth = "cluster_health_info"
	MetricdbAppIBA    = "iba"
)

// metricdbMetricResponse is generated by GET to apstra's apiUrlMetricdbMetric API endpoint
type metricdbMetricResponse struct {
	Items []metricdbResponseElem `json:"items"`
}

type metricdbResponseElem struct {
	Application string `json:"application"`
	Namespace   string `json:"namespace"`
	Name        string `json:"name"`
}

//type metricDbQuery struct {
//	Application string    `json:"application"` // required
//	Namespace   string    `json:"namespace"`   // required
//	Name        string    `json:"name"`        // required
//	BeginTime   time.Time `json:"begin_time"`  // required
//	EndTime     time.Time `json:"end_time"`    // required
//	//Filter      string `json:"filter"`
//	//Paging      struct {
//	//	PageNumber int       `json:"page_number"`
//	//	EndTime    time.Time `json:"end_time"`
//	//	PageSize   int       `json:"page_size"`
//	//	BeginTime  time.Time `json:"begin_time"`
//	//} `json:"paging"`
//	//Caching   struct {
//	//	Clear     bool `json:"clear"`
//	//	KeepAlive bool `json:"keep_alive"`
//	//	Timeout   int  `json:"timeout"`
//	//} `json:"caching"`
//	//Aggregation struct {
//	//	Metrics struct {
//	//		AdditionalProp1 string `json:"additionalProp1"`
//	//		AdditionalProp2 string `json:"additionalProp2"`
//	//		AdditionalProp3 string `json:"additionalProp3"`
//	//	} `json:"metrics"`
//	//	Period int `json:"period"`
//	//} `json:"aggregation"`
//}

type metricDbQueryResponse struct {
	Status struct {
		TotalCount    int       `json:"total_count"`
		BeginTime     time.Time `json:"begin_time"`
		EndTime       time.Time `json:"end_time"`
		ResultCode    string    `json:"result_code"`
		LastTimestamp time.Time `json:"last_timestamp"`
	} `json:"status"`
	Items json.RawMessage `json:"items"`
}

func (o *Client) getMetricdb(ctx context.Context) (*metricdbMetricResponse, error) {
	apstraUrl, err := url.Parse(apiUrlMetricdbMetric)
	if err != nil {
		return nil, fmt.Errorf("error parsing url '%s' - %w", apiUrlVersion, err)
	}
	response := &metricdbMetricResponse{}
	return response, o.talkToApstra(ctx, &talkToApstraIn{
		method:      http.MethodGet,
		url:         apstraUrl,
		apiResponse: response,
	})
}
