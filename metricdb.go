package goapstra

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"time"
)

const (
	ApiUrlMetricdbMetric = "/api/metricdb/metric"
	ApiUrlMetricdbQuery  = "/api/metricdb/query"
)

// metricdbResponse is generated by GET to apstra's apiUrlMetricdbMetric API endpoint
type metricdbResponse struct {
	Items []metricdbResponseElem `json:"items"`
}

type metricdbResponseElem struct {
	Application string `json:"application"`
	Namespace   string `json:"namespace"`
	Name        string `json:"name"`
}

type metricDbQuery struct {
	Application string    `json:"application"` // required
	Namespace   string    `json:"namespace"`   // required
	Name        string    `json:"name"`        // required
	BeginTime   time.Time `json:"begin_time"`  // required
	EndTime     time.Time `json:"end_time"`    // required
	//Filter      string `json:"filter"`
	//Paging      struct {
	//	PageNumber int       `json:"page_number"`
	//	EndTime    time.Time `json:"end_time"`
	//	PageSize   int       `json:"page_size"`
	//	BeginTime  time.Time `json:"begin_time"`
	//} `json:"paging"`
	//Caching   struct {
	//	Clear     bool `json:"clear"`
	//	KeepAlive bool `json:"keep_alive"`
	//	Timeout   int  `json:"timeout"`
	//} `json:"caching"`
	//Aggregation struct {
	//	Metrics struct {
	//		AdditionalProp1 string `json:"additionalProp1"`
	//		AdditionalProp2 string `json:"additionalProp2"`
	//		AdditionalProp3 string `json:"additionalProp3"`
	//	} `json:"metrics"`
	//	Period int `json:"period"`
	//} `json:"aggregation"`
}

type metricDbQueryResponse struct {
	Status struct {
		TotalCount    int       `json:"total_count"`
		BeginTime     time.Time `json:"begin_time"`
		EndTime       time.Time `json:"end_time"`
		ResultCode    string    `json:"result_code"`
		LastTimestamp time.Time `json:"last_timestamp"`
	} `json:"status"`
	Items json.RawMessage `json:"items"`
}

func (o Client) getMetricdb(ctx context.Context) (*metricdbResponse, error) {
	apstraUrl, err := url.Parse(ApiUrlMetricdbMetric)
	if err != nil {
		return nil, fmt.Errorf("error parsing url '%s' - %w", apiUrlVersion, err)
	}
	response := &metricdbResponse{}
	return response, o.talkToApstra(ctx, &talkToApstraIn{
		method:      http.MethodGet,
		url:         apstraUrl,
		apiResponse: response,
	})
}

//func (o Client) metricDbQuery(ctx context.Context)
