package aosSdk

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/binary"
	"encoding/pem"
	"fmt"
	"google.golang.org/protobuf/proto"
	"io"
	"net"
	"strconv"
	"strings"
	"sync"

	"github.com/chrismarget-j/apstraTelemetry/aosStreaming"
)

const (
	sizeOfAosMessageLenHdr = 2
	network                = "tcp4"
	errConnClosed          = "use of closed network connection"
)

// StreamTargetCfg is used when initializing an instance of
// StreamTarget with NewStreamTarget. If Cert or Key are nil, the
// StreamTarget will use bare TCP rather than TLS.
type StreamTargetCfg struct {
	Certificate    *x509.Certificate
	Key            *rsa.PrivateKey
	SequencingMode StreamingConfigSequencingMode
	StreamingType  StreamingConfigStreamingType
	Protocol       StreamingConfigProtocol
	Port           uint16
}

// StreamingMessage is a wrapper structure for messages delivered by both
// StreamingConfigSequencingModeSequenced channels and by
// StreamingConfigSequencingModeUnsequenced channels. In the latter case, 'seq'
// will always be nil.
type StreamingMessage struct {
	Msg *aosStreaming.AosMessage
	Seq *uint64
}

// NewStreamTarget creates a StreamTarget (socket listener) either with TLS
// support (when both x509Cert and privkey are supplied) or using bare TCP
// (when either x509Cert or privkey are nil)
func NewStreamTarget(cfg StreamTargetCfg) (*StreamTarget, error) {
	var tlsConfig *tls.Config

	if cfg.Certificate != nil && cfg.Key != nil {
		keyLog, err := keyLogWriter()
		if err != nil {
			return nil, err
		}

		certBlock := bytes.NewBuffer(nil)
		err = pem.Encode(certBlock, &pem.Block{
			Type:  "CERTIFICATE",
			Bytes: cfg.Certificate.Raw,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to pem encode certificate block - %v", err)
		}

		privateKeyBlock := bytes.NewBuffer(nil)
		err = pem.Encode(privateKeyBlock, &pem.Block{
			Type:  "RSA PRIVATE KEY",
			Bytes: x509.MarshalPKCS1PrivateKey(cfg.Key),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to pem encode private key block - %v", err)
		}

		tlsCert, err := tls.X509KeyPair(certBlock.Bytes(), privateKeyBlock.Bytes())
		if err != nil {
			return nil, fmt.Errorf("error parsing tls.Certificate object from cert and key - %v", err)
		}

		tlsConfig = &tls.Config{
			KeyLogWriter: keyLog,
			Rand:         rand.Reader,
			Certificates: []tls.Certificate{tlsCert},
		}
	}

	return &StreamTarget{
		cfg:       &cfg,
		errChan:   make(chan error),
		stopChan:  make(chan struct{}),
		msgChan:   make(chan *StreamingMessage),
		tlsConfig: tlsConfig,
	}, nil
}

// StreamTarget is a listener for AOS streaming objects
type StreamTarget struct {
	tlsConfig *tls.Config
	nl        net.Listener
	stopChan  chan struct{}
	errChan   chan error
	msgChan   chan *StreamingMessage
	clientWG  sync.WaitGroup
	cfg       *StreamTargetCfg
	//sessions    map[int]*Session
	//sessChMap   map[chan *Session]struct{}
	//sessChMutex *sync.Mutex
}

// Start loops forever handling new connections from the AOS streaming service
// as they arrive. Messages generated by socket clients are sent to msgChan.
// Receive errors are sent to errChan. An error is returned immediately if
// there's a problem starting the client handling loop.
func (o *StreamTarget) Start() (msgChan <-chan *StreamingMessage, errChan <-chan error, err error) {
	var nl net.Listener

	laddr := ":" + strconv.Itoa(int(o.cfg.Port))
	if o.tlsConfig != nil {
		nl, err = tls.Listen(network, laddr, o.tlsConfig)
	} else {
		nl, err = net.Listen(network, laddr)
	}
	if err != nil {
		return nil, nil, err
	}

	go o.receive(nl) // loop accepting incoming connections

	// this should stop everything.
	// todo: find out if this works the way i think it does
	go func() {
		<-o.stopChan      // wait for Stop() to close stopChan
		err := nl.Close() // close socket listener
		if err != nil {
			o.errChan <- err
		}
		o.clientWG.Wait() // wait for client conn handlers to exit
		close(o.errChan)  // close errChan to signal to Stop() that we're done
	}()

	return o.msgChan, o.errChan, nil
}

// Stop shuts down the receiver
func (o *StreamTarget) Stop() {
	close(o.stopChan) // signal exit to client conn handlers
	o.clientWG.Wait() // wait for client conn handlers to exit
	for range o.errChan {
	} // We're done when err channel gets closed
}

// receive loops until the listener shuts down, handing off connections from the
// AOS server to instances of handleClientConn().
func (o *StreamTarget) receive(nl net.Listener) {
	// loop accepting new connections
	for {
		conn, err := nl.Accept()
		if err != nil {
			// function ends on closure of listener nl
			if strings.HasSuffix(err.Error(), errConnClosed) {
				o.errChan <- err
				return
			}
			o.errChan <- err
			continue
		}

		o.clientWG.Add(1)
		go o.handleClientConn(conn, o.msgChan, o.errChan)
		go func() {
			<-o.stopChan
			conn.Close()
		}()
	}
}

func getBytesFromConn(i int, conn net.Conn) ([]byte, error) {
	data := make([]byte, i)
	n, err := io.ReadFull(conn, data)
	if err != nil {
		return nil, err
	}
	if n != i {
		return nil, fmt.Errorf("expected %d bytes, got %d", i, n)
	}
	return data, nil
}

func msgLenFromConn(conn net.Conn) (uint16, error) {
	msgLenHdr, err := getBytesFromConn(sizeOfAosMessageLenHdr, conn)
	if err != nil {
		return 0, err
	}
	return binary.BigEndian.Uint16(msgLenHdr), nil
}

func (o *StreamTarget) handleClientConn(conn net.Conn, msgChan chan<- *StreamingMessage, errChan chan<- error) {
	defer o.clientWG.Done()
	defer conn.Close()

	for {
		msgLen, err := msgLenFromConn(conn)
		if err != nil {
			errChan <- err
			if err == io.EOF {
				return
			}
		}

		payload, err := getBytesFromConn(int(msgLen), conn)
		if err != nil {
			errChan <- err
			if err == io.EOF {
				return
			}
		}

		msg, err := o.msgFromBytes(payload)
		if err != nil {
			errChan <- err
		} else {
			msgChan <- msg
		}
	}
}

func (o *StreamTarget) msgFromBytes(in []byte) (*StreamingMessage, error) {
	var msgOut aosStreaming.AosMessage
	var seqPtr *uint64

	// extract AosMessage from AosSequencedMessage wrapper if configured for StreamingConfigSequencingModeSequenced
	if o.cfg.SequencingMode == StreamingConfigSequencingModeSequenced {
		var seqMsg aosStreaming.AosSequencedMessage // outer wrapper structure
		err := proto.Unmarshal(in, &seqMsg)         // unwrap inner message
		if err != nil {
			return nil, err
		}
		in = seqMsg.AosProto         // redefine 'in' to payload of sequencing wrapper
		seqNum := seqMsg.GetSeqNum() // extract sequence number from sequencing wrapper
		seqPtr = &seqNum             // record address of sequence number in pointer we'll return
	}

	err := proto.Unmarshal(in, &msgOut) // extract inner message
	return &StreamingMessage{
		Msg: &msgOut, // pointer to inner message
		Seq: seqPtr,  // pointer to sequence number (nil if unsequenced)
	}, err
}
